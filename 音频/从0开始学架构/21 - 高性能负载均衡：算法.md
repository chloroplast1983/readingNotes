# 21 | 高性能负载均衡：算法

## 笔记

### 分类

* 任务平分类: 任务**平均**分配给服务器进行处理.
* 负载均衡类: 根据服务器的负载来进行分配. (CPU, IO使用率, 连接数)
* 性能最优类: 根据服务器的响应时间.
* `Hash`类: 根据任务中的某些关键信息进行`Hash`运算, 将相同`Hash`值的请求分配到同一台服务器上.

### 轮询

负载均衡系统收到请求后, 按照顺序轮流分配到服务器上.

**无须关注服务器本身的状态**, 只要服务器在运行, 运行状态是不关注. 如果服务器宕机了, 负载均衡系统是能够感知的.

### 加权轮询

根据服务器权重进行任务分配.

**解决不同服务器处理能力有差异的问题**

### 负载最低优先

**服务端角度来分配**

将任务分配给当前负载最低的服务器, 负载根据不同的任务类型和业务场景, 用不同的指标衡量. 如:

* `LVS`4层负载, 可以用"连接数"来判断服务器的状态, 服务器连接数越大, 表明服务器压力越大.
* `Nginx`7层, 可以用"HTTP 请求数"来判断服务器状态
* 如果`CPU`密集型, 可以根据`CPU`负载来衡量.
* 如果`I/O`密集型, 可以根据`I/O`负载来衡量.

复杂度会增加很多:

* 最少连接数优先的算法要求负载均衡系统统计每个服务器当前建立的连接.
	* `LVS`可以采取这种算法
	* `MySQL`连接池则不适合
* `CPU`负载最低优先的算法要求负载均衡系统收集每个服务器的`CPU`负载, 还要确定以`1`分钟的负载为标准, 还是`15`分钟的负载为标准.

**缺点**: 负载均衡系统需要感知服务器的当前的运行状态, 可能负载均衡系统和服务端都要开发代码.

### 性能最优类

**客户端角度来分配**, 优先将任务分配给处理速度最快的服务器, 通过这种方式达到最快响应客户端的目的.

通过**响应时间**这个**外部标准**来衡量服务器状态而已.

复杂度:

* 负载均衡系统需要收集和分析每个服务器每个任务的响应时间, 大量任务处理场景小消耗性能.
* 减少统计上的消耗, 可以使用采样来统计, 不统计全部, 采用抽样统计部分任务的响应时间来估算整体响应时间. **需要确定合适的采样率**
* 选择合适的采样**周期**.

### Hash 类

根据任务中的某些关键信息进行`Hash`运算, 将相同`Hash`值的请求分配到同一台服务器上.

* 源地址`hash`: 源于同一个源`IP`地址的任务分配给同一个服务器进行处理.
* `ID Hash`: 将某个`ID`标识的业务分配到同一个服务器中进行处理, 这里的`ID`一般是临时性数据的`ID`(如`session id`)

## 扩展