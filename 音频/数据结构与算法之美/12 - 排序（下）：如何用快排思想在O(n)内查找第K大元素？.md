# 12 | 排序（下）：如何用快排思想在O(n)内查找第K大元素？

## 笔记

归并排序和快速排序都用到了**分治思想**. 解决非排序问题"如何在O(n)的时间复杂度内查找一个无序数组中的第K个大元素".

### 归并排序原理

**归并排序(Merge Sort)**

核心思想:

* 把数组从中间分成前后两部分
* 对前后两部分分别排序
* 再将排好序的两部分合并在一起

![](./img/12_01.jpg)

**分治思想**, 将一个大问题分解成小的子问题来解决. 

分治思想和递归思想很像, 分治算法一般都是用**递归**来实现的. **分治是一种解决问题的处理思想, 递归是一种编程技巧**.

归并排序的递推公式:

```
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

终止条件：
p >= r 不用再继续分解
```

* `merge_sort(p…r)`, 下标从`p`到`r`之间的数组排序.
* 这个排序问题转换为两个子问题.
	* `merge_sort(p…q)`
	* `merge_sort(q+1…r)`
	* `q`等于`p`和`r`的中间位置, 也就是`(p+r)/2`

伪代码

```
// 归并排序算法, A是数组，n表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取p到r之间的中间位置q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将A[p...q]和A[q+1...r]合并为A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}
```

`merge(A[p…r], A[p…q], A[q+1…r])`的作用是, 将已经有序的`A[p…q]和 A[q+1…r]`合并成一个有序的数组.

* 申请一个临时数组`tmp`, 大小与`A[p...r]`相同. 
* 两个游标`i`和`j`, 分别指向`A[p...q]`和`A[q+1...r]`的第一个元素.
* 比较两个元素`A[i]`和`A[j]`(最小的放入到临时数组).
	* 如果`A[i]<=A[j]`, 则把`A[i]`放入到临时数组`tmp`中, `i`后移一位.
	* 否则, `A[j]`放入到数组`tmp`中, `j`后移一位.
	* 直到其中一个子数组中的所有数据都放入临时数组中, 再把另一个数组中的数据依次加入到临时数组的末尾, 这时, 临时数组中存储的就是两个子数组合并之后的结果了. 
	* 最后, 把临时数组`tmp`中的数据拷贝到原始数组`A[p...r]`中.

![](./img/12_02.jpg)

`merge()`函数伪代码

```
merge(A[p...r], A[p...q], A[q+1...r]) {
  var i := p，j := q+1，k := 0 // 初始化变量i, j, k
  var tmp := new array[0...r-p] // 申请一个大小跟A[p...r]一样的临时数组
  while i<=q AND j<=r do {
    if A[i] <= A[j] {
      tmp[k++] = A[i++] // i++等于i:=i+1
    } else {
      tmp[k++] = A[j++]
    }
  }
  
  // 判断哪个子数组中有剩余的数据
  var start := i，end := q
  if j<=r then start := j, end:=r
  
  // 将剩余的数据拷贝到临时数组tmp
  while start <= end do {
    tmp[k++] = A[start++]
  }
  
  // 将tmp中的数组拷贝回A[p...r]
  for i:=0 to r-p do {
    A[p+i] = tmp[i]
  }
}
```

备注:

```
echo k++; //0
echo k; //1
```

### 归并排序的性能分析

#### 1. 是稳定的排序算法

合并过程中, 如果`A[p…q]`和`A[q+1…r]`之间有值相同的元素, 伪代码里面是先把`A[p…q]`中的元素放入`tmp`数组. **保证了值相同的元素, 在合并前后的先后顺序不变**.

#### 2. 归并排序的时间复杂度是多少

## 扩展