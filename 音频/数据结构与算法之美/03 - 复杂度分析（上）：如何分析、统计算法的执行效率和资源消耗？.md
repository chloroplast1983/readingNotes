# 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？

## 笔记

### 为什么需要复杂度分析?

#### 事后统计法

把代码跑一遍, 通过统计, 监控, 就能得到算法执行的时间和占用的内存大小.

局限性:

1. 测试结果非常依赖测试环境. 测试环境中的硬件的不同会对测试结果有很大的影响(比如, 不同性能的处理器).
2. 测试结果受数据规模的影响很大. **所以我们需要一个不用具体的测试数据来测试, 就可以粗略地估计算法的执行效率的方法**.

### 大 O 复杂度表示法

```
# 求 1,2,3...n 的累加和

1 int cal(int n) {
2   int sum = 0;
3   int i = 1;
4   for (; i <= n; ++i) {
5     sum = sum + i;
6   }
7   return sum;
8 }
```

从`CPU`的角度来看, 这段代码的每一行都执行者类似的操作: **读数据-运算-写数据**.

* 假设每行代码执行的时间都一样, 为`unit_time`.
* 第`2,3`行代码分别需要`1`个`unit_time`的执行时间.
* 第`4,5`行都运行了`n`遍, 所以需要`2n*unit_time`的执行时间.

所以这段代码的执行时间就是`(2n+2)*unit_time`. 可以看出， **所有代码的执行时间T(n)与每行代码的执行次数成正比**.

```
1 int cal(int n) {
2   int sum = 0;
3   int i = 1;
4   int j = 1;
5   for (; i <= n; ++i) {
6     j = 1;
7     for (; j <= n; ++j) {
8       sum = sum +  i * j;
9     }
10   }
11 }
```

* `2,3,4`行需要`1`个`unit_time`
* `5,6`代码需要执行`n`遍, 需要`2n*unit_time`
* `7,8`行代码循环执行了`n^2`遍, 所以需要`2n^2*unit_time`的执行时间

`T(n) = (2n^2+2n+3)*unit_time`

**所有代码的执行时间T(n)与每行代码的执行次数 n 成正比**

**公示**

![](./img/03_01.png)

* `T(n)`, 表示代码执行的时间.
* `n`, 表示数据规模的大小.
* `f(n)`, 表示没醒代码执行的次数综合, 这是一个公示, 所以用`f(n)`来表示.
* `O`, 表示代码的执行时间`T(n)`与`f(n)`表达式成正比.

第一个例子`T(n) = O(2n+2)`, 第2个例子`T(n) = O(2n^2 + 2n +3)`. **这就是大O时间复杂度表示法**. 大O时间复杂度实际上并不具体表示代码真正的执行时间, 而是表示**代码执行时间随数据规模增长的变化趋势**(注意这里是**趋势**). 也叫做**渐进时间复杂度**(asymptotic time complexity), 简称**时间复杂度**.

**算法**

当`n`很大时. 而**公式中的低阶, 常量, 系数三部分并不左右增长趋势, 所以都可以忽略. 我们只需要记录一个最大量级就可以了.**

上面两个例子可以记为`T(n) = O(n)`, `T(n) = O(n^2)`.

### 时间复杂度分析

#### 1. 只关注循环执行次数最多的一段代码

#### 2. 加法法则: 总副再度等于量级最大的那段代码的复杂度

#### 3. 乘法法则: 嵌套代码的复杂度等于前导内外代码复杂度的乘积

### 集中常见时间复杂度实例分析

## 扩展