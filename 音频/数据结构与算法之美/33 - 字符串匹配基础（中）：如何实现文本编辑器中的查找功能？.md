# 33 | 字符串匹配基础（中）：如何实现文本编辑器中的查找功能？

## 笔记

### BM 算法的核心思想

`BF`和`RK`在模式串和主串的匹配过程中, 模式串在主串中不停地往后滑动. 当遇到不匹配的字符时, `BF`算法和`RK`算法的做法是, 模式串往后滑动一位, 然后从模式串的第一个字符开始重新匹配.

![](img/33_01.jpg)

但是因为主串的`c`, 在模式串中是不存在的, 所以, 模式串向后滑动的时候, 只要`c`与模式串与重合, 肯定无法匹配. 所以, 可以一次性把模式串往后滑动几位, 把模式串移动到`c`的后面.

![](img/33_02.jpg)

### BM 算法原理分析

**BM算法**包含两部分, **坏字符规则**(`bad character rule`)和**好后缀规则**(`good suffix shift`).

#### 1. 坏字符规则

前面的匹配过程是按模式串中的下标**从小到大**的顺序, 依次与主串中的字符进行匹配.

![](img/33_03.jpg)

**BM**算法的匹配顺序是按照模式串下标**从大到小**的顺序, 倒着匹配.

![](img/33_04.jpg)

当我们发现某个字符没法匹配的时候. 我们把这个没有匹配的字符叫做**坏字符**(主串中的字符).

拿坏字符`c`在模式串中查找, 发现模式串中并不存在这个字符. 字符`c`与模式串中的任何字符都不可能匹配. 这时, 将模式串直接往后滑动三位, 将模式串滑动到`c`后面的位置, 再从模式串末尾字符开始比较.

![](img/33_05.jpg)

这时, 模式串中最后一个字符`d`还是无法跟主串中的`a`匹配. 但是怀字符`a`在模式串中是存在的, 模式串中的小标是`0`的位置也是字符`a`. 这种情况下, 将模式串往后滑动两位, 让两个`a`上下对齐, 然后再从模式串的末尾字符开始, 重新匹配.

![](img/33_06.jpg)

第一次不匹配的时候, 滑动了三位. 第二次不匹配的时候, 将模式串后移两位. 

**移动规律**

* 坏字符对应的模式串中的字符下标记作`si`. 如果坏字符在模式中存在, 把这个坏字符在模式串中的下标记做`xi`. 如果不存在, 把`xi`记做`-1`. 那模式串往后移动的位数等于`si-xi`. 如果坏字符在模式串里多处出现, 在计算`xi`的时候, 选择最靠后的那个. 因为这样不会让模式串滑动过多, 导致本来可能匹配的情况被滑动略过.

![](img/33_07.jpg)

**最好情况**

最好情况的时间复杂度是`O(n/m)`, 主串是`aaabaaabaaabaaab`, 模式串是`aaaa`. 每次比对都可以直接后移四位.

#### 2. 好后缀规则

如果主串是`aaaaaaaaaaaaaaaa`, 模式串是`baaa`. 根据`si-xi`计算出来的移动位数, 可能是负数. 这里就需要使用"好后缀规则".

当模式串滑动到图中的位置, 模式串和主串有2个字符是匹配的, 倒数第3个字符发生了不匹配的情况.

![](img/33_08.jpg)

已经匹配的`bc`叫做好后缀, 记做`{u}`. 我们拿它在模式串中查找, 如果招到了另一个跟`{u}`相匹配的子串`{u*}`, 那我们就将模式串滑动到子串`{u*}`与主串中`{u}`对齐的位置.

![](img/33_09.jpg)

如果在模式串中找不到另一个等于`{u}`的子串, 就直接将模式串, 滑动到主串中`{u}`的后面, 因为之前的任何一次往后滑动, 都没有匹配主串中`{u}`的情况.

![](img/33_10.jpg)

这里`bc`是好后缀, 尽管在模式串中没有另外一个相匹配的子串`{u*}`, 但是如果我们将模式串移动到好后缀额后面, 就会错过模式串和主串可以匹配的情况.

![](img/33_11.jpg)

* 如果好后缀在模式中不存在可匹配的子串, 我们一步一步往后滑动模式串的过程中, 只要主串中的`{u}`与模式串有重合, 那肯定就无法完全匹配.
* 档模式串滑动到**前缀**与主串中`{u}`的后缀有部分重合的时候, 并且重合的部分相等的时候, 就有可能会存在完全匹配的情况.

![](img/33_12.jpg)

我们不仅要看**好后缀在模式串中, 是否有另一个匹配的子串, 还要看好后缀子串是否存在跟模式串的前缀子串匹配的**.

所谓某个字符串`s`的**后缀**子串, 就是最后一个字符跟`s`对齐的子串, 比如`abc`的后缀子串就包括`c,bc`. 

**前缀**子串, 就是起始字符跟`s`对齐的子串, 比如`abc`的前缀子串有`a, ab`. 

我们从好后缀的后缀子串中, 找一个最长的并且能跟模式串前缀子串匹配的, 假设是`{v}`, 然后将模式串滑动到下面图示的位置.

![](img/33_13.jpg)

### BM 算法代码实现

**坏字符规则**, 遇到坏字符时, 计算往后移动的位数`si-xi`. 需要求得`xi`. 可以将模式串中的每个字符及其下标都存到散列表中, 这样就可以快速找到坏字符在模式串的位置下标了.

假设字符串的字符集不是很大, 每个字符长度是1字节, 用大小为`256`的数组, 来记录每个字符在模式串中出现的位置. 数组的"下标"对应字符的`ASCII`码值, 数组中存储这个字符在模式串中出现的位置.

![](img/33_14.jpg)

上面的过程翻译成代码, 如下. 其中, 变量`b`是模式串, `m`是模式串的长度, `bc`是散列表.

```
private static final int SIZE = 256; // 全局变量或成员变量
private void generateBC(char[] b, int m, int[] bc) {
  for (int i = 0; i < SIZE; ++i) {
    bc[i] = -1; // 初始化bc
  }
  for (int i = 0; i < m; ++i) {
    int ascii = (int)b[i]; // 计算b[i]的ASCII值
    bc[ascii] = i;
  }
}
```

下面仅考虑坏字符规则, 不考虑`si-xi`计算得到移动位数可能会出现负数的情况.

```
public int bm(char[] a, int n, char[] b, int m) {
  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置(坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个)
  generateBC(b, m, bc); // 构建坏字符哈希表
  int i = 0; // i表示主串与模式串对齐的第一个字符
  while (i <= n - m) {
    int j;
    for (j = m - 1; j >= 0; --j) { // 模式串从后往前匹配
      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是j
    }
    if (j < 0) {
      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置
    }
    // 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位
    //坏字符对应的模式串中的字符下标记作 si. 如果坏字符在模式中存在, 把这个坏字符在模式串中的下标记做 xi. 如果不存在, 把 xi 记做 -1 . 那模式串往后移动的位数等于 si-xi 
   	// j = si, bc[(int)a[i+j]]=xi
   	// i+, 等同于移动 si - xi 位
    i = i + (j - bc[(int)a[i+j]]); 
  }
  return -1;
}
```

![](img/33_15.jpg)

#### 好后缀规则

* 在模式串中, 查找跟好后缀匹配的另一个子串.
* 在好后缀的后缀子串中, 查找最长的, 能跟模式串前缀子串匹配的后缀子串.

好后缀也是模式串本身的后缀子串, 所以, 可以在模式串和主串正式匹配之前, 通过预先处理模式串, 预先计算好模式串的每个后缀子串, 对应的另一个可匹配子串的位置.

##### 预先处理

**如何表示模式串中不同的后缀子串**

因为后缀子串最后一个字符的位置是固定的`m-1`, 所以这里只记录了长度.

![](img/33_16.jpg)

**关键变量`suffix`数组 (在模式串中, 查找跟好后缀匹配的另一个子串)**, `suffix`数组的下标`k`, 表示后缀子串的长度, 下标对应的数组值存储的是, 子啊模式串中跟好后缀`{u}`想匹配的子串`{u*}`的起始下标值.

![](img/33_17.jpg)

如果模式串中有多个(大于1个)子串跟后缀子串`{u}`匹配, 那`suffix`数组中存储模式串中靠后的那个子串的起始位置, 也就是下标最大的那个子串的起始位置.

**`boolean`类型的`prefix`数组**, 记录模式串的后缀子串是否能匹配模式串的**前缀子串**.

![](img/33_18.jpg)

**如何计算并填充这两个数组的值**

下标从`0`到`i`的子串(`i`可以是`0`到`m-2`)与整个模式串, 求公共后缀子串. 如果公共后缀的子串的长度是`k`, 那我们就记录`suffix[k]=j`(`j`表示公共后缀子串的起始下标), 如果`j`等于`0`, 也就是说, 公共后缀子串也是模式串的前缀子串, 就记录`prefix[k]=true`.

![](img/33_19.jpg)

```
// b表示模式串，m表示长度，suffix，prefix数组事先申请好了
private void generateGS(char[] b, int m, int[] suffix, boolean[] prefix) {
  for (int i = 0; i < m; ++i) { // 初始化
    suffix[i] = -1;
    prefix[i] = false;
  }
  for (int i = 0; i < m - 1; ++i) { // b[0, i]
    int j = i;
    int k = 0; // 公共后缀子串长度
    while (j >= 0 && b[j] == b[m-1-k]) { // 与b[0, m-1]求公共后缀子串
      --j;
      ++k;
      suffix[k] = j+1; //j+1表示公共后缀子串在b[0, i]中的起始下标
    }
    if (j == -1) prefix[k] = true; //如果公共后缀子串也是模式串的前缀子串
  }
}
```

**在模式串跟主串匹配的过程中, 遇到不能匹配的字符时, 如何根据好后缀规则, 计算模式串往后滑动的位数?**

假设好好后缀的长度是`k`. 我们先拿好后缀, 在`suffix`数组中查找其匹配的子串. 如果`suffix[k]`不等于`-1`(`-1`表示不匹配的子串), 那我们就将模式串往后移动`j-suffix[k]+1`位(`j`表示坏字符对应的模式串中的字符下标). 如果`suffix[k]`等于`-1`, 表示模式串中不存在另一个跟好后缀匹配的子串片段. 用下面规则来处理.

![](img/33_20.jpg)

好后缀的后缀子串`b[r, m-1]`(其中, `r`取值从`j+2`到`m-1`)的长度`k=m-r`, 如果`prefix[k]`等于`true`, 表示长度为`k`的后缀子串, 有可匹配的前缀子串, 这样我们就可以把模式串后移`r`位.

![](img/33_21.jpg)

如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串, 我们就将整个模式串后移`m`位.

![](img/33_22.jpg)

```
// a,b表示主串和模式串；n，m表示主串和模式串的长度。
public int bm(char[] a, int n, char[] b, int m) {
  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置
  generateBC(b, m, bc); // 构建坏字符哈希表
  int[] suffix = new int[m];
  boolean[] prefix = new boolean[m];
  generateGS(b, m, suffix, prefix);
  int i = 0; // j表示主串与模式串匹配的第一个字符
  while (i <= n - m) {
    int j;
    for (j = m - 1; j >= 0; --j) { // 模式串从后往前匹配
      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是j
    }
    if (j < 0) {
      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置
    }
    int x = j - bc[(int)a[i+j]];
    int y = 0;
    if (j < m-1) { // 如果有好后缀的话
      y = moveByGS(j, m, suffix, prefix);
    }
    i = i + Math.max(x, y);
  }
  return -1;
}

// j表示坏字符对应的模式串中的字符下标; m表示模式串长度
private int moveByGS(int j, int m, int[] suffix, boolean[] prefix) {
  int k = m - 1 - j; // 好后缀长度
  if (suffix[k] != -1) return j - suffix[k] +1;
  for (int r = j+2; r <= m-1; ++r) {
    if (prefix[m-r] == true) {
      return r;
    }
  }
  return m;
}
```

## 扩展