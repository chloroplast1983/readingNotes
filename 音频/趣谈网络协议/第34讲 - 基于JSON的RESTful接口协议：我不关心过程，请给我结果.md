# 第34讲 | 基于JSON的RESTful接口协议：我不关心过程，请给我结果

## 笔记

### 传输协议问题

对比刚才的`SOAP`:

* 创建订单可以用`POST`, 里面放订单信息.
* 删除订单可以用`DELETE`, 里面放订单`id`即可.

### 协议约定问题

`RESTful`不仅仅是指`API`, 而是一种架构风格. 全称`Representational State Transfer`, **表属性状态转移**.

`REST`不是一种严格规定的标准, 它其实是一种设计风格.

* `REST`关注的是架构.
* `SOAP`关注的是接口.

**客户端和服务端谁来维护状态. 所谓的状态就是对某个数据当前处理到什么程度了**.

举例, 我们使用`NFS`,当客户端输入`cd hello`, 服务端要在某个地方记住,上次浏览到`/root/test`了, 因为客户的这次输入, 应该给它显示`/root/test/hello`.

上面的例子是在`RPC`的场景下, 由服务端来维护状态. 这种模式原来没有问题, 因为客户端和服务端之间的比例没有失衡. 因为一般不会同时有太多的客户端同时连上来, 所以`NFS`还能把每个客户端的状态都记住.

但是互联网场景下, 客户端和服务端就彻底失衡了. 多少人同时购物, 作为服务端, 就记不过来.

当客户端维护了自己的状态, 就不能这样调用服务端了. 原来通过`cd hello`调用, 现在需要告诉服务端`/root/test/hello`的完整路径.

这就是**服务端的无状态化**. 服务端就可以横向扩展了.

**所谓的无状态, 就是服务端维护资源状态, 客户端维护会话状态**. 

* 对于服务端来说, 只有资源的状态改变了, 客户端才调用`POST`,`PUT`,`DELETE`方法来找我.
* 如果资源状态没变, 只是客户端状态变了, 就不用告诉我, 对于我来说统一就是`GET`.

虽然只改进了`GET`, 就已经带来了很大的进步. 对于互联网应用, 大多数是**读多写少**. 而且只要服务端的资源状态不变, 就可以进行缓存.

按照这种思路, 对于`API`设计, 就慢慢变成了以资源为核心, 而非以过程为核心. **客户端只要告诉服务端你想让资源状态最终编程什么样就可以了, 而不用告诉过程, 不用告诉动作**.

这种`API`的设计需要实现幂等. 因为网络不稳定, 就会存在幂等问题. 不能进入`cd a`, 做了三次, 就变成了`cd a/a/a`.

### 服务发现问题



## 扩展