# 第17讲 | P2P协议：我下小电影，99%急死你

## 笔记

### FTP 下载

采用两个`TCP`链接来传输一个文件.

* 控制连接: 服务器以被动的方式, 打开`21`端口, 客户端则主动发起链接. 该连接将命令从客户端传给服务器, 并传回服务器的应答. 
	* list 获取文件目录
	* reter 取一个文件
	* store 存一个文件
* 数据连接: 每当一个文件在客户端与服务器之间传输, 就创建一个数据连接.
	* 对于每一个文件都要新建一个数据链接.

#### FTP 的两种工作模式

* 主动模式(PORT)
* 被动模式(PASV)

##### 主动模式(服务器主动连接)

**服务器连接客户端**

客户端随机打开一个大于`1024`的端口`N`, 向服务器的命令端口`21`发起连接, 同时开放`N+1`端口监听, 并向服务器发出`port N+1`命令, 有服务器从自己的数据端口`20`**主动连接**到客户端指定的数据端口`N+1`.

##### 被动模式(服务器被动连接)

**客户端连接服务器端**

当开启一个`FTP`连接时, 客户端打开两个任意的本地端口`N`(大于`1024`)和`N+1`. 第一个端口连接服务器的`21`端口, 提交`PASV`命令. 然后, 服务器会开启一个任意的端口`P`(大于1024), 返回`227 entering passive mode`消息, 里面有`FTP`服务器开放的用来进行数据传输的端口. **客户端收到消息取得端口之后, 会通过`N+1`号端口连接服务器的端口`P`, 然后在两个端口之间进行数据传输**.

### P2P是什么

`peer-to-peer`. 资源并不集中的存储在某些设备上, 而是分散地存储在多态设备上. 这些设备就是`peer`.

下载文件时, 和这些存了文件的`peer`之间建立点对点的连接, 不需要到中心服务器上, 就可以下载文件. 一旦下载了文件, 别的机器也可能会选择从你这里下载文件.

**参与的人越多, 下载越快**

#### 种子(.torrent)文件

怎么知道哪些`peer`有这个文件呢?

`.torrent`文件:

* announce(tracker URL)
* 文件信息
	* `info`区, 该种子有几个文件, 文件有多长, 目录结构, 以及目录和文件的名字.
	* `Name`字段, 指定顶层目录名字.
	* 每个段的大小: BitTorrent协议把一个文件分成很多小段, 然后分段下载.
	* 段哈希值: 将整个种子中, 每个段的`SHA-1`哈希值拼在一起.(用来鉴别下载数据正确与否)

#### 下载过程

* 客户端解析`.torrent`文件, 等到`tracker`地址.
* 连接`tracker`服务器, 获取其他下载者的(包括发布者)的`IP`提供给下载者. 
* 下载者再连接其他下载者, 根据`.torrent`文件, 双反告知已经有的块, 交换没有的块.
* 下载者每得到一个块, 算出下载块的`Hash`验证码, 并与`.torrent`文件中的对比(校验下载内容正确性).
	* 一样, 说明块正确.
	* 不一样, 重新下载该块.

**总结**依赖`tracker`. `tracker`需要收集下载者信息的服务器, 并将这些信息提供给其他下载者, 使下载者们互连接起来,传输数据. 

* 下载过程是**非中心化**的.
* 加入这个`P2P`网络, 需要借助`tracker`中心服务器. **中心化**.

### 去中心化网络(DHT)

`DHT(Distributed Hash Table)`去中心化网络. 每个加入这个`DHT`网络的人, 都要负责存储这个网络里的资源信息和其他成员的联系信息.

#### `Kademlia`协议

一种`DHT`协议, 类似区块链的概念一样.

任何一个`BitTorrent`启动之后:

* `peer`, 监听一个`TCP`的端口, 用来上传和下载文件, 这个角色表名, 我这里有某个人间.
* `DHT node`: 监听一个`UDP`的端口, 通过这个角色, 这个节点加入一个`DHT`的网络.

![](./img/17_01.jpg)

每一个`DHT node`都有一个`ID`(一个很长的串). 每个`DHT node`都掌握一些知识(文件索引, **它应该知道某些文件是保存在哪些节点上**. 它自己本身不一定就是保存这个文件的节点.

#### 哈希值

`DHT node`不会有全局只是, 也不知道所有的文件保存在哪. 它需要知道的这一部分,需要用**哈希算法**计算出来.

每个文件可以计算一个哈希值, **DHT node 的 ID 是和哈希值相同长度的串**.

DHT 算法规定: **如果一个文件计算出一个哈希值, 这这个夏至一样的那个 DHT node, 就有责任知道从哪里下载这个文件, 即便它没有保存这个文件**.

**ID和这个哈希值非常接近的N个DHT node 也应该知道**(万一哈希值一样的节点都下线了)

**哈希值接近**, 修改倒数N位, 凑齐N个节点为止.

#### DHT 网络示例

一个新的节点上线, 想下载文件1.

* 种子`.torrent`文件里面是一个`list`的`node`地址(不再是`tracker`地址), 假设总有一个能联系上.
* 只要在种子里面找到一个`DHT node`, 就加入网络.
* 计算文件1的哈希值, 根据这个哈希值了解到, 匹配或者很接近的`node`上知道如何下载这个文件, 假如是`node C`.
* 新的`node`不知道如何联系`C`, 因为种子里面的`node`可能没有`node C`. 
* 在`DHT`网络中, 每个`node`都保存了一定的联系方式, 但是没有`node`的所有联系方式.
* 新的`node`只能去问, 朋友在问朋友. 如果找不到C, 就找和C的`ID`很像的节点.
* `node C`, 告诉新加入的`node`, 下载文件1, 需要去B,D,F. 
* 新`node`选择和`node B`进行`peer`连接, 开始下载.
* 新`node`拥有了文件1, 告诉`node C`以及和`node C`很像的节点, 我也有文件1了,可以假如那个文件拥有者列表了.
* 现在新`node`还没有文件索引, 后续在`DHT`节点网络中, 会有节点告诉它, 新`node`也有责任知道某些文件的下载地址(文建索引)

#### DHT ID相似

通过异或(XOR)计算. 

```
01010 与 01000 的距离是两个ID的异或值, 为00010, 也即为2.
01010 与 00010 的距离为 01000, 即为8
01010 与 00011 的举例为 01001, 即8+1=9
```

* 高位不同, 表示距离远一些
* 低位不同, 表示距离更近一些

总的距离为所有的不同的位的举例之和.

**不能比喻为物理位置**, 在`Kademila`网络中, 位置近不算近, ID近才算近.

## 扩展