# 12. BASH 条件句和控制结构

## 使用条件句和控制结构优化 Bash Shell 脚本

* 使用 Bash 特殊变量
* 评估退出代码
* 测试脚本输入
* 使用条件结构

### 使用 Bash 特殊变量

#### 位置参数

位置参数是变量, 可将命令行参数的值存储到脚本中. 将以数字方式对变量进行命名. 

* 变量 0 指的是脚本名称自身.
* 预定义变量 1 时, 以脚本的第一个参数作为其值.
* 变量 2 包含第二个参数.
* 以此类推, 可以使用语法 $1, $2 来引用值.

**当超过第九个位置参数时, 必须使用花括号阔气的变量扩展形式, 如`${10}`**, 如果使用**`$10`**, Bash 会将`$1`扩展到脚本的第一个位置参数的值.

* `$*`, 所有参数都将被视为一个单词.
* `$@`, 每个参数都被视为单独单词.
* `$#`, 表示传递给脚本的命令行参数数量.

### 评估退出代码

每个命令返回一个退出状态, 通常称为返回状态或退出代码.

* 如果命令成功, 退出时的退出状态为0.
* 如果命令不成功, 退出时的退出状态不为0.

完成后, 命令的退出状态将传递到父进程并存储在**?**变量中.

已执行命令的退出状态可通过显示**`$?`**的值来检索.

可使用可选的整数参数(0到255)之间表示退出代码来执行`exit`命令.

退出代码值**0**表示没有错误. 所有其他**非零值**都表示存在错误的退出代码. **该退出代码传递回父进程, 父进程将其存储在 `?` 变量中, 可以使用`$?`来访问**.

### 测试脚本输入

#### 整数比较

* `-eq` 等于 `[ "$a" -eq "b" ]`
* `-ne` 不等于 `[ "$a" -ne "b" ]`
* `-gt` 大于 `[ "$a" -gt "b" ]`
* `-ge` 大于等于 `[ "$a" -ge "b" ]`
* `-lt` 小于 `[ "$a" -lt "b" ]`
* `-le` 小于等于 `[ "$a" -le "b" ]`

#### 字符串比较

* `=` 等于 `[ "$a" = "b" ]`
* `==` 等于 `[ "$a" == "b" ]`
* `!=` 不等于 `[ "$a" != "b" ]`
* `-z` 字符串的长度为零 `[ -z "a" ]`
* `-n` 字符串不为空 `[ -n "a" ]`

#### 测试文件和目录

* `-b` 文件存在并且是块 `[ -b <FILE> ]`
* `-c` 文件存在并且是字符 `[ -c <FILE> ]`
* `-d` 文件存在并且是目录 `[ -d <DIRECTORY> ]`
* `-e` 文件存在 `[ -e <FILE> ]`
* `-f` 文件是常规文件 `[ -f <FILE> ]`
* `-L` 文件存在并且是符号链接 `[ -L <FILE> ]`
* `-r` 文件存在并且授予了读权限 `[ -r <FILE> ]`
* `-s` 文件存在并且大小大于零 `[ -s <FILE> ]`
* `-w` 文件存在并且授予了写权限 `[ -w <FILE> ]`
* `-x` 文件存在并且授予了执行(或搜索)权限 `[ -x <FILE> ]`

* `-cf` 两个设备和索引节点编号相同 `[ <FILE1> -ef <FILE2> ]`
* `-nt` 文件一的修改日期比文件二晚 `[ <FILE1> -nt <FILE2> ]`
* `-ot` 文件一的修改日期比文件二晚 `[ <FILE1> -ot <FILE2> ]`

#### 逻辑 AND OR 运算符

* `&&` 执行复合条件测试以了解两个条件是否均成立.
* `||` 允许用户测试两个条件中的一个是否成立.

### 使用条件结构

#### `if/then`

```shell
if <CONDITION>; then
	<STATEMENT>
	...
	<STATEMENT>
fi
```

#### `if/then/else`

```shell
if <CONDITION>; then
	<STATEMENT>
	...
	<STATEMENT>
else
	<STATEMENT>
	...
	<STATEMENT>
fi
```

#### `if/then/elif/then/else`

```shell
if <CONDITION>; then
	<STATEMENT>
	...
	<STATEMENT>
elif <CONDITION>; then
	<STATEMENT>
	...
	<STATEMENT>
else
	<STATEMENT>
	...
	<STATEMENT>
fi
```

#### `case`

```shell
case <VALUE> in
	<PATTERN1>)
		<STATEMENT>
		...
		<STATEMENT>
		;;
	<PATTERN2>)
		<STATEMENT>
		...
		<STATEMENT>
		;;
esac
```

可以使用管道符`|`分隔多个模式.

```shell

case "$1" in
	...
	reload|restart)
		restart
		;;
	...
esac
```